package it.water.user.repository;

import it.water.core.api.model.PaginableResult;
import it.water.core.api.repository.query.Query;
import it.water.core.api.repository.query.QueryBuilder;
import it.water.core.api.repository.query.QueryOrder;
import it.water.core.api.security.EncryptionUtil;
import it.water.core.interceptors.annotations.FrameworkComponent;
import it.water.core.interceptors.annotations.Inject;
import it.water.core.model.exceptions.WaterRuntimeException;
import it.water.core.permission.exceptions.UnauthorizedException;
import it.water.repository.entity.model.exceptions.NoResultException;
import it.water.repository.jpa.WaterJpaRepositoryImpl;
import it.water.user.api.UserRepository;
import it.water.user.api.options.UserOptions;
import it.water.user.model.WaterUser;
import lombok.Setter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.nio.charset.StandardCharsets;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.util.Base64;

/**
 * @Generated by Water Generator
 * Repository Class for User entity.
 */
@FrameworkComponent
public class UserRepositoryImpl extends WaterJpaRepositoryImpl<WaterUser> implements UserRepository {
    private static Logger logger = LoggerFactory.getLogger(UserRepositoryImpl.class);
    private static final String USER_PERSISTENCE_UNIT = "user-persistence-unit";
    @Inject
    @Setter
    private EncryptionUtil encryptionUtil;
    @Inject
    @Setter
    private UserOptions userOptions;

    public UserRepositoryImpl() {
        super(WaterUser.class, USER_PERSISTENCE_UNIT);
    }

    /**
     * Find an existing user by username via query
     *
     * @param username parameter required to find an existing user
     * @return the user with username entered
     */
    public WaterUser findByUsername(String username) {
        logger.debug("Repository findByUsername {}", username);
        try {
            QueryBuilder qb = this.getQueryBuilderInstance();
            Query byUsername = qb.field("username").equalTo(username);
            return this.find(byUsername);
        } catch (NoResultException e) {
            logger.debug("Entity not found...");
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        }
        return null;
    }

    /**
     * Find an existing user by username via query
     *
     * @param email parameter required to find an existing user
     * @return the user with username entered
     */
    public WaterUser findByEmail(String email) {
        logger.debug("Repository findByEmail {}", email);
        try {
            QueryBuilder qb = this.getQueryBuilderInstance();
            Query byEmail = qb.field("email").equalTo(email.toLowerCase()).and(qb.field("deleted").equalTo(false));
            return this.find(byEmail);
        } catch (NoResultException e) {
            logger.debug("Entity not found...");
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        }
        return null;
    }

    /**
     * @param email          of the user that must be activated
     * @param activationCode the registration activation code
     */
    public void activateUser(String email, String activationCode) {
        WaterUser user = findByEmail(email);
        if (user != null) {
            if (user.isActive()) {
                throw new WaterRuntimeException("User already activated");
            }
            if (user.getActivateCode().equals(activationCode)) {
                activateUser(user);
            } else {
                throw new UnauthorizedException("Activation failed!");
            }
        }
    }

    /**
     * @param userId user id of the user that must be activated
     */
    public void activateUser(long userId) {
        WaterUser user = find(userId);
        activateUser(user);
    }

    /**
     * @param user object
     */
    public void activateUser(WaterUser user) {
        user.setActivateCode(null);
        user.setActive(true);
        this.update(user);
    }

    /**
     * @param userId of the user to be deactivated
     */
    @Override
    public void deactivateUser(long userId) {
        WaterUser user = find(userId);
        if (user != null) {
            user.setActive(false);
            this.update(user);
        }
    }

    /**
     * @param email        of the user that must be deleted
     * @param deletionCode deletion code
     */
    public void unregisterUser(String email, String deletionCode) {
        WaterUser user = findByEmail(email);
        if (user != null && user.getDeletionCode().equalsIgnoreCase(deletionCode)) {
            if (this.userOptions.isPhysicalDeletionEnabled()) {
                this.remove(user.getId());
            } else {
                user.setDeleted(true);
                this.update(user);
            }
        }
    }

    /**
     * Forcing password update after all checks are done
     *
     * @param id
     * @param salt
     * @param password
     */
    public WaterUser updatePassword(long id, byte[] salt, String password) {
        WaterUser user = find(id);
        processUserPassword(user, password, salt);
        return this.update(user);
    }

    @Override
    public WaterUser persist(WaterUser entity) {
        //On persist password is plain, before saving with hash it
        processUserPassword(entity, entity.getPassword(), entity.getSalt().getBytes(StandardCharsets.UTF_8));
        return super.persist(entity);
    }

    @Override
    public PaginableResult<WaterUser> findAllDeleted(int delta, int page, Query filter, QueryOrder queryOrder) {
        return super.findAll(delta, page, customizeWithDeletedFilter(true, filter), queryOrder);
    }

    @Override
    public long countAllDeleted(Query filter) {
        return super.countAll(customizeWithDeletedFilter(true, filter));
    }

    @Override
    public PaginableResult<WaterUser> findAll(int delta, int page, Query filter, QueryOrder queryOrder) {
        return super.findAll(delta, page, customizeWithDeletedFilter(false, filter), queryOrder);
    }

    @Override
    public long countAll(Query filter) {
        return super.countAll(customizeWithDeletedFilter(false, filter));
    }

    private Query customizeWithDeletedFilter(boolean deletedUserValue, Query originalFilter) {
        QueryBuilder qb = this.getQueryBuilderInstance();
        Query deletedFilter = qb.field("deleted").equalTo(deletedUserValue);
        if (originalFilter == null) {
            originalFilter = deletedFilter;
        } else {
            originalFilter = originalFilter.and(deletedFilter);
        }
        return originalFilter;
    }

    private String hashPassword(byte[] salt, String password) {
        try {
            return new String(encryptionUtil.hashPassword(salt, password));
        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
            throw new WaterRuntimeException(e);
        }
    }

    private void processUserPassword(WaterUser user, String password, byte[] salt) {
        String pwdHash = hashPassword(salt, password);
        String saltStr = Base64.getEncoder().encodeToString(salt);
        user.updatePassword(saltStr, pwdHash, pwdHash);
        user.setPasswordResetCode(null);
    }
}
