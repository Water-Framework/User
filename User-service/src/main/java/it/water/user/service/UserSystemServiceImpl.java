package it.water.user.service;

import it.water.core.api.bundle.Runtime;
import it.water.core.api.interceptors.OnActivate;
import it.water.core.api.model.PaginableResult;
import it.water.core.api.model.User;
import it.water.core.api.permission.SecurityContext;
import it.water.core.api.repository.query.Query;
import it.water.core.api.repository.query.QueryOrder;
import it.water.core.api.security.EncryptionUtil;
import it.water.core.api.user.UserManager;
import it.water.core.interceptors.annotations.FrameworkComponent;
import it.water.core.interceptors.annotations.Inject;
import it.water.core.model.exceptions.ValidationException;
import it.water.core.model.exceptions.WaterRuntimeException;
import it.water.core.model.validation.ValidationError;
import it.water.core.permission.exceptions.UnauthorizedException;
import it.water.repository.entity.model.exceptions.DuplicateEntityException;
import it.water.repository.entity.model.exceptions.EntityNotFound;
import it.water.repository.entity.model.exceptions.NoResultException;
import it.water.repository.service.BaseEntitySystemServiceImpl;
import it.water.user.api.UserRepository;
import it.water.user.api.UserSystemApi;
import it.water.user.api.options.UserOptions;
import it.water.user.model.WaterUser;
import lombok.Getter;
import lombok.Setter;

import java.nio.charset.StandardCharsets;
import java.util.*;

/**
 * @Generated by Water Generator
 * System Service Api Class for User entity.
 */
@FrameworkComponent
public class UserSystemServiceImpl extends BaseEntitySystemServiceImpl<WaterUser> implements UserSystemApi, UserManager {
    private static final String USER_REGISTRATION_DISABLED_MESSAGE = "User registration is disabled!";
    @Inject
    @Setter
    @Getter
    private UserRepository repository;
    @Inject
    @Setter
    private UserOptions userOptions;

    @Inject
    @Setter
    private EncryptionUtil encryptionUtil;

    @Inject
    @Setter
    private Runtime runtime;

    public UserSystemServiceImpl() {
        super(WaterUser.class);
    }

    /**
     * On Activation let's check if the main admin exists, if not let's create it.
     */
    @OnActivate
    public void onActivate(UserRepository userRepository, UserOptions userOptions, EncryptionUtil encryptionUtil) {
        try {
            userRepository.find(userRepository.getQueryBuilderInstance().field("username").equalTo("admin"));
        } catch (NoResultException e) {
            String tempPassword = userOptions.defaultAdminPwd();
            byte[] salt = encryptionUtil.generate16BytesSalt();
            String saltString = Base64.getEncoder().encodeToString(salt);
            WaterUser adminUser = new WaterUser("Admin", "Admin", "admin", tempPassword, saltString, true, "hadmin@water.it");
            adminUser.setActive(true);
            adminUser.updatePassword(saltString, tempPassword, tempPassword);
            userRepository.persist(adminUser);
        }
    }


    @Override
    public WaterUser register(WaterUser waterUser) {
        if (!userOptions.isRegistrationEnabled())
            throw new UnauthorizedException(USER_REGISTRATION_DISABLED_MESSAGE);
        if (!waterUser.getPasswordConfirm().equals(waterUser.getPassword())) {
            throw new ValidationException(Collections.singletonList(new ValidationError("Password do not match", "password", "-")));
        }
        return super.save(waterUser);
    }

    @Override
    public void activateUser(String email, String activationCode) {
        if (!userOptions.isRegistrationEnabled())
            throw new UnauthorizedException(USER_REGISTRATION_DISABLED_MESSAGE);
        repository.activateUser(email, activationCode);
    }

    @Override
    public void activateUser(long userId) {
        if (!userOptions.isRegistrationEnabled())
            throw new UnauthorizedException(USER_REGISTRATION_DISABLED_MESSAGE);
        repository.activateUser(userId);
    }

    @Override
    public void deactivateUser(long userId) {
        repository.deactivateUser(userId);
    }

    @Override
    public PaginableResult<WaterUser> findAllDeleted(int delta, int page, Query filter, QueryOrder queryOrder) {
        return repository.findAllDeleted(delta, page, filter, queryOrder);
    }

    @Override
    public long countAllDeleted(Query filter) {
        return repository.countAllDeleted(filter);
    }

    @Override
    public void unregister(String email, String deletionCode) {
        if (!userOptions.isRegistrationEnabled())
            throw new UnauthorizedException(USER_REGISTRATION_DISABLED_MESSAGE);
        repository.unregisterUser(email, deletionCode);
    }

    @Override
    public WaterUser findByUsername(String username) {
        return this.repository.findByUsername(username);
    }

    @Override
    public WaterUser findByEmail(String email) {
        return this.repository.findByEmail(email);
    }

    @Override
    public WaterUser changeDeletionCode(String deletionCode) {
        SecurityContext securityContext = runtime.getSecurityContext();
        if (securityContext == null || securityContext.getLoggedEntityId() <= 0)
            throw new UnauthorizedException("Not logged in");
        WaterUser dbUser = this.find(securityContext.getLoggedEntityId());
        if (dbUser == null)
            throw new EntityNotFound();
        try {
            dbUser.setDeletionCode(deletionCode);
            return this.update(dbUser);
        } catch (Exception e) {
            getLog().error(e.getMessage(), e);
            throw new WaterRuntimeException("Impossible to update user deletion code");
        }
    }

    @Override
    public WaterUser changePassword(WaterUser user, String password, String passwordConfirm) {
        byte[] salt = encryptionUtil.generate16BytesSalt();
        String saltString = Base64.getEncoder().encodeToString(salt);
        //Setting just to fire validation
        user.updatePassword(saltString, password, passwordConfirm);
        this.validate(user);
        //invoking repository update in order to bypass password reset logic
        return repository.updatePassword(user.getId(), salt, password);
    }

    @Override
    public User addUser(String username, String name, String lastname, String email, String password, String salt, boolean isAdmin) {
        WaterUser newUser = new WaterUser(name, lastname, username, password, salt, isAdmin, email);
        return this.save(newUser);
    }

    @Override
    public WaterUser update(WaterUser entity) {
        WaterUser userFromDb = find(entity.getId());
        //Validating with fake password since this method does not change the password itself
        entity.updatePassword("tempSalt", "Password_1", "Password_1");
        super.validate(entity);
        //If validation is ok, we force old password, bypassing validation which is already done
        String saltString = Base64.getEncoder().encodeToString(userFromDb.getSalt().getBytes());
        entity.updatePassword(saltString, userFromDb.getPassword(), userFromDb.getPassword());
        //calling update won't re-hash password so, basically here we just force the previous calculated hash
        try {
            return repository.update(entity);
        } catch (DuplicateEntityException e) {
            this.getLog().warn("Update failed: entity is duplicated!");
            throw e;
        } catch (NoResultException e) {
            this.getLog().warn("Update failed: entity to update not found!");
            throw e;
        } catch (Exception e1) {
            throw new WaterRuntimeException(e1.getMessage());
        }
    }

    @Override
    public void removeUser(String username) {
        WaterUser user = findByUsername(username);
        this.remove(user.getId());
    }

    @Override
    public User findUser(String username) {
        return findByUsername(username);
    }

    @Override
    public Collection<User> all() {
        List<User> users = new ArrayList<>();
        users.addAll(findAll(null, 10, 1, null).getResults());
        return users;
    }
}